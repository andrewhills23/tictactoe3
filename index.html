<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic-Tac-Toe (Level 3)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --text-color: #333;
            --accent: #4a90e2;
            --line-thin: #ccc;
            --line-med: #888;
            --line-thick: #000;
        }

        body.dark-theme { --bg-color: #1a1a1a; --text-color: #f0f2f5; --line-thin: #444; --line-med: #666; --line-thick: #aaa; }
        body.newspaper-theme { --bg-color: #f4e4bc; --text-color: #2c2c2c; --line-thick: #1a1a1a; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            transition: background 0.3s;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-color);
            z-index: 10;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        h1 { font-size: 3rem; margin-bottom: 2rem; }
        h2 { margin-bottom: 1.5rem; }

        button {
            padding: 12px 24px;
            font-size: 1.2rem;
            margin: 10px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: var(--accent);
            color: white;
            transition: transform 0.1s, opacity 0.2s;
        }
        button:hover { opacity: 0.9; transform: scale(1.05); }
        button:disabled { background-color: #ccc; cursor: not-allowed; transform: none; }
        .danger-btn { background-color: #e74c3c; }
        .secondary-btn { background-color: #7f8c8d; }
        .selected { border: 3px solid #000; transform: scale(1.05); font-weight: bold; }

        input { padding: 10px; font-size: 1.2rem; border-radius: 5px; border: 1px solid #ccc; margin-bottom: 1rem; }

        /* --- GAME WRAPPER --- */
        #game-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            opacity: 0; 
            transition: opacity 0.6s ease;
        }
        
        /* THE BOARD: 27x27 Grid */
        #main-area { position: relative; }
        #board {
            display: grid;
            grid-template-columns: repeat(27, 20px); /* 27 cells wide */
            grid-template-rows: repeat(27, 20px);
            border: 3px solid var(--line-thick);
            background: white;
            user-select: none;
        }

        .cell {
            width: 20px;
            height: 20px;
            border-right: 1px solid var(--line-thin);
            border-bottom: 1px solid var(--line-thin);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
        }

        /* Thicker Borders for the "Big" and "Middle" grids */
        .b-right-med { border-right: 2px solid var(--line-med); }
        .b-bottom-med { border-bottom: 2px solid var(--line-med); }
        .b-right-thick { border-right: 3px solid var(--line-thick); }
        .b-bottom-thick { border-bottom: 3px solid var(--line-thick); }

        /* Zones */
        .legal-zone { background-color: rgba(0, 255, 0, 0.05); }
        .legal-zone:hover { background-color: rgba(0, 255, 0, 0.2); }
        .disabled-zone { background-color: rgba(0, 0, 0, 0.05); cursor: default; }
        
        .x-mark { color: #e74c3c; font-weight: bold; }
        .o-mark { color: #3498db; font-weight: bold; }

        /* Overlays for won grids */
        .won-overlay {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: bold;
            opacity: 0.6;
            pointer-events: none;
        }
        .winner-X { color: #e74c3c; background: rgba(231, 76, 60, 0.1); }
        .winner-O { color: #3498db; background: rgba(52, 152, 219, 0.1); }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .label-strip { display: flex; position: absolute; pointer-events: none; }
        #col-labels { top: -20px; left: 0; width: 100%; justify-content: space-around; font-size: 10px; }
        #row-labels { left: -20px; top: 0; height: 100%; flex-direction: column; justify-content: space-around; font-size: 10px; }

        #turn-display-container {
            background: #fff; padding: 15px; border-radius: 8px; text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #big-mark { font-size: 3rem; font-weight: bold; }
        .turn-x #big-mark { color: #e74c3c; }
        .turn-o #big-mark { color: #3498db; }

        #log-wrapper {
            background: #fff; height: 150px; border-radius: 8px; padding: 10px;
            overflow-y: auto; font-size: 0.9rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .log-entry { padding: 4px 0; border-bottom: 1px solid #eee; }

        #chat-sidebar {
            display: none; /* Flex when online */
            flex-direction: column;
            height: 200px;
            background: #fff;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #chat-messages-area { flex: 1; overflow-y: auto; font-size: 0.85rem; margin-bottom: 5px; }
        .chat-msg { margin-bottom: 4px; }
        .chat-msg.system { color: #888; font-style: italic; }
        .chat-msg.mine { color: #2ecc71; text-align: right; }
        .chat-msg.theirs { color: #3498db; text-align: left; }

        /* --- MODALS --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        .modal.active { opacity: 1; pointer-events: all; }
        .modal-content {
            background: white; padding: 30px; border-radius: 10px;
            text-align: center; max-width: 400px; width: 90%;
        }
    </style>
</head>
<body>

    <div id="start-screen" class="screen">
        <h1>Ultimate Tic-Tac-Toe</h1>
        <div style="font-size: 1.5rem; margin-bottom: 20px;">Level 3 (27x27)</div>
        <button id="main-play-btn">Play Game</button>
    </div>

    <div id="mode-screen" class="screen hidden">
        <h2>Select Mode</h2>
        <button id="friend-mode-btn">Play vs Friend</button>
        <button id="computer-mode-btn">Play vs Computer</button>
        <div style="margin-top: 20px;"></div>
        <button id="themes-menu-btn" class="secondary-btn">Themes</button>
    </div>

    <div id="friend-select-screen" class="screen hidden">
        <h2>Multiplayer</h2>
        <button id="local-friend-btn">Local (Same Device)</button>
        <button id="online-friend-btn">Online (Different Device)</button>
        <button id="friend-back-btn" class="secondary-btn">Back</button>
    </div>

    <div id="name-input-screen" class="screen hidden">
        <h2>Enter Your Name</h2>
        <input type="text" id="player-name-input" placeholder="Your Name" maxlength="12">
        <div>
            <button id="confirm-name-btn">Continue</button>
            <button id="name-back-btn" class="secondary-btn">Back</button>
        </div>
    </div>

    <div id="side-select-screen" class="screen hidden">
        <h2>Choose Your Side</h2>
        <div>
            <button id="host-pick-x" class="side-btn">Play as X</button>
            <button id="host-pick-o" class="side-btn">Play as O</button>
        </div>
        <button id="side-back-btn" class="secondary-btn">Back</button>
    </div>

    <div id="online-lobby-screen" class="screen hidden">
        <h2>Invite Your Friend</h2>
        <p>Send this link to your friend:</p>
        <div style="display:flex; gap:10px; margin-bottom:20px;">
            <input type="text" id="invite-link" readonly style="width:300px;">
            <button id="copy-link-btn" style="margin:0; padding:10px;">Copy</button>
        </div>
        <div id="connection-status" style="font-weight:bold; color:orange;">Waiting for connection...</div>
        <button id="lobby-back-btn" class="secondary-btn">Cancel</button>
    </div>

    <div id="settings-screen" class="screen hidden">
        <h2>Computer Settings</h2>
        <p>Select Difficulty:</p>
        <div style="display:flex; gap:10px; margin-bottom:20px;">
            <button class="diff-btn selected" id="btn-diff-easy" onclick="selectDifficulty('easy')">Easy</button>
            <button class="diff-btn" id="btn-diff-medium" onclick="selectDifficulty('medium')">Medium</button>
            <button class="diff-btn" id="btn-diff-hard" onclick="selectDifficulty('hard')">Hard</button>
        </div>
        <p>Select Side:</p>
        <div style="display:flex; gap:10px; margin-bottom:20px;">
            <button class="side-btn selected" id="btn-side-x" onclick="selectSide('X')">Play as X</button>
            <button class="side-btn" id="btn-side-o" onclick="selectSide('O')">Play as O</button>
        </div>
        <button id="start-game-btn">Start Game</button>
        <button id="settings-back-btn" class="secondary-btn">Back</button>
    </div>

    <div id="themes-screen" class="screen hidden">
        <h2>Select Theme</h2>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
            <button class="theme-btn selected" id="btn-theme-light" onclick="setTheme('light')">Light</button>
            <button class="theme-btn" id="btn-theme-dark" onclick="setTheme('dark')">Dark</button>
            <button class="theme-btn" id="btn-theme-newspaper" onclick="setTheme('newspaper')">Newspaper</button>
        </div>
        <button id="themes-back-btn" class="secondary-btn" style="margin-top:20px;">Back</button>
    </div>

    <div id="game-wrapper" class="hidden">
        <div id="main-area">
            <div id="col-labels" class="label-strip"></div>
            <div id="row-labels" class="label-strip"></div>
            <div id="board"></div>
        </div>
      
        <div id="sidebar">
            <div id="turn-display-container" class="turn-x">
                <div class="label-text">Current Turn</div>
                <div id="big-mark">X</div>
            </div>

            <div id="timer-container" style="background:white; padding:10px; border-radius:8px; text-align:center;">
                <div class="label-text">Timer</div>
                <div class="timer-row">
                    <div id="timer-display" style="font-size:1.5rem; font-family:monospace;">00:00</div>
                    <button id="pause-btn" class="control-btn" style="font-size:0.8rem; padding:5px;">Pause</button>
                </div>
            </div>

            <div id="log-wrapper">
                <div class="label-text" style="text-align: left; border-bottom: 1px solid var(--line-thin); padding-bottom: 5px;">Move History</div>
                <div id="activity-log"></div>
            </div>

            <div id="chat-sidebar">
                <div id="chat-messages-area"></div>
                <div style="display:flex;">
                    <input type="text" id="chat-input" placeholder="Say hi..." style="width:100%; margin:0; font-size:0.8rem;">
                    <button id="chat-send" style="margin:0; padding:5px 10px;">&rarr;</button>
                </div>
            </div>

            <div id="sidebar-actions">
                <div id="bottom-controls" style="display:flex; justify-content:space-between;">
                    <button id="sound-btn" class="control-btn">ðŸ”Š</button>
                    <button id="theme-open-btn" class="control-btn">ðŸŽ¨</button>
                </div>
                <button id="menu-btn" class="action-btn secondary-btn" style="width:100%;">Main Menu</button>
                <button id="clear-btn" class="action-btn danger-btn" style="width:100%;">Reset Board</button>
            </div>
        </div>
    </div>

    <div id="win-screen" class="modal">
        <div class="modal-content">
            <h1 id="win-title">X Wins!</h1>
            <button id="play-again-btn">Play Again</button>
            <button id="view-board-btn" class="secondary-btn">View Board</button>
        </div>
    </div>

    <div id="pause-screen" class="modal">
        <div class="modal-content">
            <h1>Paused</h1>
            <div id="paused-time" style="font-size:2rem; margin-bottom:20px;"></div>
            <button id="resume-btn">Resume</button>
        </div>
    </div>

    <div id="confirm-modal" class="modal">
        <div class="modal-content">
            <h2 id="confirm-title">Are you sure?</h2>
            <p id="confirm-desc">This action cannot be undone.</p>
            <button id="confirm-yes-btn" class="danger-btn">Yes</button>
            <button id="confirm-no-btn" class="secondary-btn">Cancel</button>
        </div>
    </div>

    <div id="disconnect-modal" class="modal">
        <div class="modal-content">
            <h2>Connection Lost</h2>
            <p>Your friend disconnected.</p>
            <button id="disconnect-new-btn">Main Menu</button>
            <button id="disconnect-menu-btn" class="secondary-btn">Reset Board (Local)</button>
        </div>
    </div>

    <div id="ingame-theme-modal" class="modal">
        <div class="modal-content">
            <h2>Change Theme</h2>
            <div style="display:flex; flex-direction:column; gap:10px;">
                <button class="theme-btn-ingame" id="ig-theme-light" onclick="setTheme('light')">Light</button>
                <button class="theme-btn-ingame" id="ig-theme-dark" onclick="setTheme('dark')">Dark</button>
                <button class="theme-btn-ingame" id="ig-theme-newspaper" onclick="setTheme('newspaper')">Newspaper</button>
            </div>
            <button id="close-theme-modal" class="secondary-btn" style="margin-top:20px;">Close</button>
        </div>
    </div>

<script>
/* --- DOM ELEMENTS --- */
const startScreen = document.getElementById("start-screen");
const modeScreen = document.getElementById("mode-screen");
const settingsScreen = document.getElementById("settings-screen");
const themesScreen = document.getElementById("themes-screen");
const friendSelectScreen = document.getElementById("friend-select-screen");
const nameInputScreen = document.getElementById("name-input-screen");
const sideSelectScreen = document.getElementById("side-select-screen");
const onlineLobbyScreen = document.getElementById("online-lobby-screen");
const winScreen = document.getElementById("win-screen");
const pauseScreen = document.getElementById("pause-screen");
const confirmModal = document.getElementById("confirm-modal");
const disconnectModal = document.getElementById("disconnect-modal");
const ingameThemeModal = document.getElementById("ingame-theme-modal"); 
const gameWrapper = document.getElementById("game-wrapper");
const board = document.getElementById("board");
const colLabels = document.getElementById("col-labels");
const rowLabels = document.getElementById("row-labels");

const mainPlayBtn = document.getElementById("main-play-btn");
const friendModeBtn = document.getElementById("friend-mode-btn");
const computerModeBtn = document.getElementById("computer-mode-btn");
const themesMenuBtn = document.getElementById("themes-menu-btn");
const themesBackBtn = document.getElementById("themes-back-btn");
const startGameBtn = document.getElementById("start-game-btn");
const settingsBackBtn = document.getElementById("settings-back-btn");
const playAgainBtn = document.getElementById("play-again-btn");
const viewBoardBtn = document.getElementById("view-board-btn");
const pauseBtn = document.getElementById("pause-btn");
const resumeBtn = document.getElementById("resume-btn");
const soundBtn = document.getElementById("sound-btn"); 
const themeOpenBtn = document.getElementById("theme-open-btn"); 
const closeThemeModalBtn = document.getElementById("close-theme-modal"); 

const menuBtn = document.getElementById("menu-btn");
const clearBtn = document.getElementById("clear-btn");
const confirmYesBtn = document.getElementById("confirm-yes-btn");
const confirmNoBtn = document.getElementById("confirm-no-btn");
const confirmTitle = document.getElementById("confirm-title");
const confirmDesc = document.getElementById("confirm-desc");

const turnContainer = document.getElementById("turn-display-container");
const bigMark = document.getElementById("big-mark");
const winTitle = document.getElementById("win-title");
const activityLog = document.getElementById("activity-log");
const timerDisplay = document.getElementById("timer-display");
const pausedTimeDisplay = document.getElementById("paused-time");

/* Friend Screen Elements */
const localFriendBtnElem = document.getElementById("local-friend-btn");
const onlineFriendBtnElem = document.getElementById("online-friend-btn");
const friendBackBtn = document.getElementById("friend-back-btn");
const lobbyBackBtn = document.getElementById("lobby-back-btn");
const inviteLinkInput = document.getElementById("invite-link");
const copyLinkBtn = document.getElementById("copy-link-btn");
const connectionStatus = document.getElementById("connection-status");

/* Name & Side Elements */
const playerNameInput = document.getElementById("player-name-input");
const confirmNameBtn = document.getElementById("confirm-name-btn");
const nameBackBtn = document.getElementById("name-back-btn");
const hostPickX = document.getElementById("host-pick-x");
const hostPickO = document.getElementById("host-pick-o");
const sideBackBtn = document.getElementById("side-back-btn");

/* Disconnect Elements */
const disconnectNewBtn = document.getElementById("disconnect-new-btn");
const disconnectMenuBtn = document.getElementById("disconnect-menu-btn");

/* Chat Elements */
const chatSidebar = document.getElementById("chat-sidebar");
const chatMessagesArea = document.getElementById("chat-messages-area");
const chatInput = document.getElementById("chat-input");
const chatSendBtn = document.getElementById("chat-send");

/* --- STATE --- */
let turn = "X";
let nextMoveConstraint = null; 
let isGameOver = false;
let isVsComputer = false;
let isPaused = false;
let isMuted = false; 
let currentTheme = 'light';
const cells = [];
let middleGridState = new Array(81).fill(null);
let bigGridState = new Array(9).fill(null);
let moveHistoryData = []; 

let playerSide = "X";
let computerDifficulty = "easy";
let timerInterval = null;
let secondsElapsed = 0;
let pendingConfirmAction = null; 

/* NETWORKING STATE */
let isOnline = false;
let peer = null;
let conn = null;
let myNetworkSide = null; // 'X' or 'O' if online
let myName = "Player 1";
let opponentName = "Player 2";
let isHost = false; 

const SAVE_KEY = 'tictactoe3_save';

const THEME_NAMES = {
  'light': 'Light Mode',
  'dark': 'Dark Mode',
  'newspaper': 'Newspaper'
};

/* --- SOUND ENGINE --- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
  if (isMuted) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();

  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  if (type === 'X') {
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.15);
  } else {
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
    gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.1);
  }
}

function playButtonSound() {
  if (isMuted) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc.type = 'sine';
  osc.frequency.setValueAtTime(330, audioCtx.currentTime); 
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
  
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}

function playWinHum() {
  if (isMuted) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();

  const frequencies = [523.25, 659.25, 783.99]; 
  frequencies.forEach(freq => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.05, now + 0.1); 
    gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5); 
    
    osc.start(now);
    osc.stop(now + 1.5);
  });
}

soundBtn.addEventListener("click", () => {
  isMuted = !isMuted;
  if (isMuted) {
    soundBtn.textContent = "ðŸ”‡";
  } else {
    soundBtn.textContent = "ðŸ”Š";
  }
  saveGame(); 
});

/* THEME MODAL LOGIC */
themeOpenBtn.addEventListener("click", () => {
  if(!isGameOver && !isPaused) stopTimer(); 
  ingameThemeModal.classList.add("active");
  document.querySelectorAll('.theme-btn-ingame').forEach(btn => btn.classList.remove('selected'));
  const btn = document.getElementById('ig-theme-'+currentTheme);
  if(btn) btn.classList.add('selected');
});

closeThemeModalBtn.addEventListener("click", () => {
  ingameThemeModal.classList.remove("active");
  if(!isGameOver && !isPaused) startTimer(true); 
});

document.querySelectorAll('button').forEach(btn => {
  if(btn.id !== 'sound-btn') {
    btn.addEventListener('click', playButtonSound);
  }
});

/* --- INIT --- */
window.addEventListener('load', () => {
  // Check for invite link
  const urlParams = new URLSearchParams(window.location.search);
  const gameId = urlParams.get('game');

  if (gameId) {
    // JOIN AS GUEST
    startScreen.classList.add("hidden");
    isHost = false;
    nameInputScreen.classList.remove("hidden");
    window.targetGameId = gameId;
  } else {
    // Normal load
    const savedData = localStorage.getItem(SAVE_KEY);
    if (savedData) {
      loadGameState(JSON.parse(savedData));
    }
  }
});

/* --- NAME SCREEN LOGIC --- */
confirmNameBtn.addEventListener("click", () => {
  const inputName = playerNameInput.value.trim();
  if (inputName) {
    myName = inputName;
    
    // UI FEEDBACK FOR CHROMEBOOKS
    confirmNameBtn.textContent = "Connecting...";
    confirmNameBtn.disabled = true;

    if (isHost) {
      nameInputScreen.classList.add("hidden");
      sideSelectScreen.classList.remove("hidden");
      confirmNameBtn.textContent = "Continue";
      confirmNameBtn.disabled = false;
    } else {
      // Connect as Guest - wait for connection before hiding
      initializePeer(window.targetGameId);
    }
  } else {
    alert("Please enter a name.");
  }
});

nameBackBtn.addEventListener("click", () => {
  nameInputScreen.classList.add("hidden");
  if (isHost) {
    friendSelectScreen.classList.remove("hidden");
  } else {
    startScreen.classList.remove("hidden");
  }
});

/* --- SIDE SELECT LOGIC (HOST) --- */
hostPickX.addEventListener("click", () => {
  playerSide = 'X';
  sideSelectScreen.classList.add("hidden");
  onlineLobbyScreen.classList.remove("hidden");
  initializePeer();
});

hostPickO.addEventListener("click", () => {
  playerSide = 'O';
  sideSelectScreen.classList.add("hidden");
  onlineLobbyScreen.classList.remove("hidden");
  initializePeer();
});

sideBackBtn.addEventListener("click", () => {
  sideSelectScreen.classList.add("hidden");
  nameInputScreen.classList.remove("hidden");
});

/* --- PEERJS LOGIC (FIXED FOR CHROMEBOOKS) --- */
function initializePeer(targetId = null) {
  // CONFIG CHANGE: Add secure:true and STUN servers
  peer = new Peer(null, {
    debug: 2,
    secure: true,
    config: {
      'iceServers': [
        { url: 'stun:stun.l.google.com:19302' },
        { url: 'stun:stun1.l.google.com:19302' }
      ]
    }
  });
  
  peer.on('error', (err) => {
      console.error(err);
      alert("Connection Error. School wifi might be blocking PeerJS.");
      confirmNameBtn.textContent = "Try Again";
      confirmNameBtn.disabled = false;
  });
  
  peer.on('open', (id) => {
    console.log('My peer ID is: ' + id);
    if (!targetId) {
      // HOST MODE
      const link = `${window.location.origin}${window.location.pathname}?game=${id}`;
      inviteLinkInput.value = link;
      isOnline = true;
      myNetworkSide = playerSide; 
      
      peer.on('connection', (c) => {
        setupConnection(c);
        connectionStatus.textContent = "Friend Connected! Sending Game Data...";
        connectionStatus.style.color = "green";
        
        setTimeout(() => {
            c.send({ 
              type: 'init', 
              name: myName, 
              hostSide: myNetworkSide,
              theme: currentTheme
            });
        }, 500);
      });
    } else {
      // GUEST MODE
      isOnline = true;
      const c = peer.connect(targetId, { reliable: true });
      setupConnection(c);
      
      c.on('open', () => {
        console.log("Connected to Host");
        // FIX: Now hide the screen
        nameInputScreen.classList.add("hidden");
        confirmNameBtn.textContent = "Continue"; 
        confirmNameBtn.disabled = false;
      });
      
      setTimeout(() => {
          if(!c.open) {
              alert("Connection timed out.");
              confirmNameBtn.textContent = "Continue";
              confirmNameBtn.disabled = false;
          }
      }, 5000);
    }
  });
}

function setupConnection(c) {
  conn = c;
  
  conn.on('data', (data) => {
    handleNetworkData(data);
  });
  
  conn.on('close', () => {
    isOnline = false;
    disconnectModal.classList.add("active");
  });
}

function handleNetworkData(data) {
  if (data.type === 'init') {
    // Guest receives init data
    opponentName = data.name;
    setTheme(data.theme, false);
    myNetworkSide = (data.hostSide === 'X') ? 'O' : 'X';
    playerSide = myNetworkSide; 
    
    sendData({ type: 'name', name: myName });
    
    // Start Game
    modeScreen.classList.add("hidden"); 
    launchGame();
    addChatMessage(`Connected to ${opponentName}`, 'system');

  } else if (data.type === 'name') {
    // Host receives Guest name
    opponentName = data.name;
    onlineLobbyScreen.classList.add("hidden");
    launchGame();
    addChatMessage(`${opponentName} connected!`, 'system');

  } else if (data.type === 'move') {
    const cell = cells.find(c => parseInt(c.dataset.row) === data.row && parseInt(c.dataset.col) === data.col);
    if (cell) executeMove(cell, data.row, data.col, false); 
  } else if (data.type === 'chat') {
    const msgSide = (myNetworkSide === 'X') ? 'O' : 'X';
    addChatMessage(data.msg, 'theirs', opponentName, msgSide);
  } else if (data.type === 'reset') {
    resetGame(false, false); 
  } else if (data.type === 'theme') {
    setTheme(data.theme, false);
    const niceName = THEME_NAMES[data.theme] || data.theme;
    addChatMessage(`${data.name} changed the theme to ${niceName}`, 'system');
  } else if (data.type === 'pauseState') {
    setPauseState(data.isPaused);
    const action = data.isPaused ? 'paused' : 'resumed';
    addChatMessage(`${data.name} ${action} the game`, 'system');
  }
}

function sendData(data) {
  if (isOnline && conn && conn.open) {
    conn.send(data);
  }
}

/* --- DISCONNECT HANDLING --- */
disconnectNewBtn.addEventListener("click", () => {
  disconnectModal.classList.remove("active");
  if (peer) { peer.destroy(); peer = null; isOnline = false; }
  gameWrapper.style.opacity = "0";
  gameWrapper.classList.add("hidden");
  onlineLobbyScreen.classList.add("hidden");
  friendSelectScreen.classList.add("hidden");
  nameInputScreen.classList.remove("hidden");
  isHost = true; 
});

disconnectMenuBtn.addEventListener("click", () => {
  disconnectModal.classList.remove("active");
  resetGame(true);
});

/* --- THEME LOGIC --- */
function setTheme(theme, propagate = true) {
  currentTheme = theme;
  document.body.classList.remove('dark-theme', 'newspaper-theme');
  if (theme !== 'light') document.body.classList.add(theme + '-theme');
  
  document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('selected'));
  const themeBtn = document.getElementById(`btn-theme-${theme}`);
  if(themeBtn) themeBtn.classList.add('selected');
  
  document.querySelectorAll('.theme-btn-ingame').forEach(btn => btn.classList.remove('selected'));
  const igBtn = document.getElementById(`ig-theme-${theme}`);
  if(igBtn) igBtn.classList.add('selected');

  if (ingameThemeModal.classList.contains("active")) {
    ingameThemeModal.classList.remove("active");
    if(!isGameOver && !isPaused) startTimer(true); 
  }

  if (propagate && isOnline) {
    sendData({ type: 'theme', theme: theme, name: myName });
    const niceName = THEME_NAMES[theme] || theme;
    addChatMessage(`You changed the theme to ${niceName}`, 'system');
  }

  saveGame();
}

/* --- NAVIGATION --- */
mainPlayBtn.addEventListener("click", () => {
  startScreen.classList.add("hidden");
  modeScreen.classList.remove("hidden");
  if (audioCtx.state === 'suspended') audioCtx.resume();
});

themesMenuBtn.addEventListener("click", () => {
  modeScreen.classList.add("hidden");
  themesScreen.classList.remove("hidden");
});

themesBackBtn.addEventListener("click", () => {
  themesScreen.classList.add("hidden");
  modeScreen.classList.remove("hidden");
});

friendModeBtn.addEventListener("click", () => {
  modeScreen.classList.add("hidden");
  friendSelectScreen.classList.remove("hidden");
});

/* MULTIPLAYER SUBMENU */
localFriendBtnElem.addEventListener("click", () => {
  isVsComputer = false;
  isOnline = false;
  friendSelectScreen.classList.add("hidden");
  launchGame();
});

onlineFriendBtnElem.addEventListener("click", () => {
  friendSelectScreen.classList.add("hidden");
  isHost = true;
  nameInputScreen.classList.remove("hidden");
});

document.getElementById("friend-back-btn").addEventListener("click", () => {
  friendSelectScreen.classList.add("hidden");
  modeScreen.classList.remove("hidden");
});

document.getElementById("lobby-back-btn").addEventListener("click", () => {
  onlineLobbyScreen.classList.add("hidden");
  modeScreen.classList.remove("hidden");
  if (peer) { peer.destroy(); peer = null; isOnline = false; }
});

copyLinkBtn.addEventListener("click", () => {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(inviteLinkInput.value).then(() => {
      copyLinkBtn.textContent = "Copied!";
      setTimeout(() => copyLinkBtn.textContent = "Copy", 2000);
    }).catch(err => {
      inviteLinkInput.select();
      document.execCommand("copy");
      copyLinkBtn.textContent = "Copied!";
      setTimeout(() => copyLinkBtn.textContent = "Copy", 2000);
    });
  } else {
    inviteLinkInput.select();
    document.execCommand("copy");
    copyLinkBtn.textContent = "Copied!";
    setTimeout(() => copyLinkBtn.textContent = "Copy", 2000);
  }
});

computerModeBtn.addEventListener("click", () => {
  isVsComputer = true;
  isOnline = false;
  modeScreen.classList.add("hidden");
  settingsScreen.classList.remove("hidden");
});

settingsBackBtn.addEventListener("click", () => {
  settingsScreen.classList.add("hidden");
  modeScreen.classList.remove("hidden");
});

function selectSide(side) {
  playerSide = side;
  document.querySelectorAll('.side-btn').forEach(btn => btn.classList.remove('selected'));
  document.getElementById(`btn-side-${side.toLowerCase()}`).classList.add('selected');
}

function selectDifficulty(diff) {
  computerDifficulty = diff;
  document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
  document.getElementById(`btn-diff-${diff}`).classList.add('selected');
}

startGameBtn.addEventListener("click", () => {
  settingsScreen.classList.add("hidden");
  launchGame();
});

function launchGame() {
  if (isOnline) {
    chatSidebar.style.display = 'flex';
  } else {
    chatSidebar.style.display = 'none';
  }

  startTimer();
  
  // FIX: Explicitly remove hidden class
  gameWrapper.classList.remove("hidden");
  gameWrapper.style.opacity = "0";
  
  setTimeout(() => {
    gameWrapper.style.opacity = "1";
    if (isVsComputer && playerSide === "O") {
        setTimeout(makeComputerMove, 800);
    }
    updateBoardVisuals(); 
    saveGame();
  }, 200);
}

/* MODIFIED MENU & CLEAR LOGIC */
menuBtn.addEventListener("click", () => {
  if(!isGameOver && !isPaused) togglePause(false, true); 
  pendingConfirmAction = 'menu';
  confirmTitle.textContent = "Exit to Menu?";
  confirmDesc.textContent = "This will clear your current board and progress.";
  confirmYesBtn.textContent = "Exit Game";
  confirmModal.classList.add("active");
});

clearBtn.addEventListener("click", () => {
  if(!isGameOver && !isPaused) togglePause(false, true); 
  pendingConfirmAction = 'clear';
  confirmTitle.textContent = "Clear Board?";
  confirmDesc.textContent = "This will wipe your current progress.";
  confirmYesBtn.textContent = "Yes, Clear";
  confirmModal.classList.add("active");
});

confirmNoBtn.addEventListener("click", () => {
  confirmModal.classList.remove("active");
  if(!isGameOver && isPaused && gameWrapper.style.opacity === "1") togglePause(false, true); 
});

confirmYesBtn.addEventListener("click", () => {
  confirmModal.classList.remove("active");
  if (pendingConfirmAction === 'menu') {
    resetGame(true); 
  } else {
    resetGame(false, true); 
  }
});

playAgainBtn.addEventListener("click", () => resetGame(false, true));
viewBoardBtn.addEventListener("click", () => {
  winScreen.classList.remove("active");
  stopTimer();
});

pauseBtn.addEventListener("click", () => togglePause(false, true)); 
resumeBtn.addEventListener("click", () => togglePause(false, true));

function togglePause(fromNetwork = false, propagate = false) {
  if (isGameOver) return;
  setPauseState(!isPaused);
  if (propagate && isOnline) {
    sendData({ type: 'pauseState', isPaused: isPaused, name: myName });
    const action = isPaused ? 'paused' : 'resumed';
    addChatMessage(`You ${action} the game`, 'system');
  }
}

function setPauseState(paused) {
  isPaused = paused;
  if (isPaused) {
    stopTimer();
    pausedTimeDisplay.textContent = timerDisplay.textContent;
    pauseScreen.classList.add("active");
  } else {
    startTimer(true);
    pauseScreen.classList.remove("active");
  }
}

/* CHAT LOGIC */
chatSendBtn.addEventListener("click", sendChatMessage);
chatInput.addEventListener("keypress", (e) => { if(e.key === 'Enter') sendChatMessage(); });

function sendChatMessage() {
  const text = chatInput.value.trim();
  if (text) {
    addChatMessage(text, 'mine', myName, myNetworkSide);
    sendData({ type: 'chat', msg: text });
    chatInput.value = "";
  }
}

function addChatMessage(text, type, senderName, side = null) {
  const div = document.createElement("div");
  let sideClass = '';
  if (side === 'X') sideClass = 'msg-x';
  if (side === 'O') sideClass = 'msg-o';
  
  div.className = `chat-msg ${type} ${sideClass}`;
  
  if (type === 'system') {
    div.textContent = text;
  } else {
    const nameSpan = document.createElement("div");
    nameSpan.className = "chat-name";
    nameSpan.textContent = senderName;
    
    const msgSpan = document.createElement("span");
    msgSpan.textContent = text;
    
    div.appendChild(nameSpan);
    div.appendChild(msgSpan);
  }
  
  chatMessagesArea.appendChild(div);
  chatMessagesArea.scrollTop = chatMessagesArea.scrollHeight;
}

function startTimer(resuming = false) {
  if (!resuming) {
    updateTimerDisplay();
  }
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    secondsElapsed++;
    updateTimerDisplay();
    saveGame();
  }, 1000);
}

function stopTimer() {
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = null;
}

function updateTimerDisplay() {
  const m = Math.floor(secondsElapsed / 60);
  const s = secondsElapsed % 60;
  timerDisplay.textContent = `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

// GENERATE 27x27 BOARD
for (let i = 0; i < 27 * 27; i++) {
  const cell = document.createElement("div");
  cell.className = "cell legal-zone"; 
  cell.dataset.index = i;
  const row = Math.floor(i / 27);
  const col = i % 27;
  cell.dataset.row = row;
  cell.dataset.col = col;

  if ((col + 1) % 9 === 0) cell.classList.add("b-right-thick");
  else if ((col + 1) % 3 === 0) cell.classList.add("b-right-med");
  if ((row + 1) % 9 === 0) cell.classList.add("b-bottom-thick");
  else if ((row + 1) % 3 === 0) cell.classList.add("b-bottom-med");

  board.appendChild(cell);
  cells.push(cell);
  cell.addEventListener("click", () => handleMove(cell, row, col));
}

// LABELS
for (let i = 1; i <= 27; i++) {
  const colNum = document.createElement("div"); colNum.textContent = i; colLabels.appendChild(colNum);
  const rowNum = document.createElement("div"); rowNum.textContent = i; rowLabels.appendChild(rowNum);
}

function handleMove(cell, row, col) {
  if (isGameOver || isPaused) return; 
  if (isVsComputer && turn !== playerSide) return;
  if (isOnline && turn !== myNetworkSide) return;

  if (cell.textContent !== "") return;
  if (!isMoveLegal(row, col)) return;

  executeMove(cell, row, col, true);

  if (isVsComputer && !isGameOver && turn !== playerSide) {
    setTimeout(makeComputerMove, 600);
  }
}

function executeMove(cell, row, col, broadcast = false) {
  if (broadcast && isOnline) {
    sendData({ type: 'move', row: row, col: col });
  }

  addLogEntry(turn, row, col);
  playSound(turn);

  cell.textContent = turn;
  applyMarkStyles(cell);

  let wonSomething = false;
  if (checkMiddleGridWin(row, col)) {
    wonSomething = true;
    const mgRow = Math.floor(row / 3);
    const mgCol = Math.floor(col / 3);
    const bgRow = Math.floor(mgRow / 3);
    const bgCol = Math.floor(mgCol / 3);
    if (checkBigGridWin(bgRow, bgCol)) checkGlobalWin();
  }

  if (isGameOver) { 
    stopTimer(); 
    updateBoardVisuals(); 
    saveGame();
    return; 
  }
  
  if (wonSomething) nextMoveConstraint = null; 
  else calculateNextConstraint(row, col);

  switchTurn();
  updateBoardVisuals();
  saveGame();
}

function makeComputerMove() {
  if (isGameOver || isPaused) return;

  const legalCells = cells.filter(cell => {
    const r = parseInt(cell.dataset.row);
    const c = parseInt(cell.dataset.col);
    return cell.textContent === "" && isMoveLegal(r, c);
  });

  if (legalCells.length === 0) return;

  let chosenCell = null;
  const computerMark = (playerSide === "X") ? "O" : "X";
  let smartMoveChance = 0; 
  if (computerDifficulty === "easy") smartMoveChance = 0;
  if (computerDifficulty === "medium") smartMoveChance = 0.5;
  if (computerDifficulty === "hard") smartMoveChance = 0.9;
  if (computerDifficulty === "expert") smartMoveChance = 1.0;

  if (Math.random() < smartMoveChance) {
    chosenCell = findBestMoveFor(legalCells, computerMark);
    if (!chosenCell) chosenCell = findBestMoveFor(legalCells, playerSide);
    if (!chosenCell && computerDifficulty === "expert") {
       chosenCell = legalCells.find(cell => {
         const r = parseInt(cell.dataset.row);
         const c = parseInt(cell.dataset.col);
         return (r % 3 === 1) && (c % 3 === 1);
       });
    }
  }

  if (!chosenCell) {
    const randomIndex = Math.floor(Math.random() * legalCells.length);
    chosenCell = legalCells[randomIndex];
  }

  const r = parseInt(chosenCell.dataset.row);
  const c = parseInt(chosenCell.dataset.col);
  executeMove(chosenCell, r, c);
}

function findBestMoveFor(legalMoves, markToCheck) {
  for (let cell of legalMoves) {
    const r = parseInt(cell.dataset.row);
    const c = parseInt(cell.dataset.col);
    if (simulatesLocalWin(r, c, markToCheck)) return cell;
  }
  return null;
}

function simulatesLocalWin(r, c, mark) {
  const mgRow = Math.floor(r / 3);
  const mgCol = Math.floor(c / 3);
  const startR = mgRow * 3;
  const startC = mgCol * 3;
  let localGrid = [[null,null,null],[null,null,null],[null,null,null]];
  for(let i=0; i<3; i++) {
    for(let j=0; j<3; j++) {
      const idx = (startR+i)*27 + (startC+j);
      localGrid[i][j] = cells[idx].textContent;
    }
  }
  localGrid[r%3][c%3] = mark;
  for(let i=0; i<3; i++) if(localGrid[i][0]==mark && localGrid[i][1]==mark && localGrid[i][2]==mark) return true;
  for(let i=0; i<3; i++) if(localGrid[0][i]==mark && localGrid[1][i]==mark && localGrid[2][i]==mark) return true;
  if(localGrid[0][0]==mark && localGrid[1][1]==mark && localGrid[2][2]==mark) return true;
  if(localGrid[0][2]==mark && localGrid[1][1]==mark && localGrid[2][0]==mark) return true;
  return false;
}

function addLogEntry(player, r, c) {
  moveHistoryData.unshift({ player, r, c });
  renderLogEntry(player, r, c);
}

function renderLogEntry(player, r, c) {
  const entry = document.createElement("div");
  entry.className = "log-entry";
  const x = c + 1;
  const y = r + 1;
  const markSpan = `<span class="log-mark ${player === 'X' ? 'log-x' : 'log-o'}">${player}</span>`;
  entry.innerHTML = `${markSpan} placed at <strong>(${x}, ${y})</strong>`;
  activityLog.insertBefore(entry, activityLog.firstChild);
}

function isMoveLegal(r, c) {
  if (isGameOver) return false;
  const mgRow = Math.floor(r / 3);
  const mgCol = Math.floor(c / 3);
  const mgIndex = mgRow * 9 + mgCol;
  const bgRow = Math.floor(mgRow / 3);
  const bgCol = Math.floor(mgCol / 3);
  const bgIndex = bgRow * 3 + bgCol;

  if (middleGridState[mgIndex] !== null) return false;
  if (bigGridState[bgIndex] !== null) return false;

  if (!nextMoveConstraint) return true;
  const { r: rRange, c: cRange } = nextMoveConstraint;
  return (r >= rRange[0] && r < rRange[1] && c >= cRange[0] && c < cRange[1]);
}

function checkMiddleGridWin(r, c) {
  const mgRow = Math.floor(r / 3);
  const mgCol = Math.floor(c / 3);
  const mgIndex = mgRow * 9 + mgCol;
  if (middleGridState[mgIndex] !== null) return false;
  const startR = mgRow * 3;
  const startC = mgCol * 3;
  const getCell = (dr, dc) => cells[(startR + dr) * 27 + (startC + dc)].textContent;
  const winner = checkGridLogic(getCell);
  if (winner) {
    middleGridState[mgIndex] = winner;
    createOverlay(mgRow, mgCol, winner, "middle");
    playWinHum();
    return true;
  }
  return false;
}

function checkBigGridWin(bgRow, bgCol) {
  const bgIndex = bgRow * 3 + bgCol;
  if (bigGridState[bgIndex] !== null) return false;
  const startMgRow = bgRow * 3;
  const startMgCol = bgCol * 3;
  const getMgOwner = (dr, dc) => middleGridState[(startMgRow + dr) * 9 + (startMgCol + dc)];
  const winner = checkGridLogic(getMgOwner);
  if (winner) {
    bigGridState[bgIndex] = winner;
    createOverlay(bgRow, bgCol, winner, "big");
    playWinHum();
    return true;
  }
  return false;
}

function checkGlobalWin() {
  const getBgOwner = (dr, dc) => bigGridState[dr * 3 + dc];
  const winner = checkGridLogic(getBgOwner);
  if (winner) {
    isGameOver = true;
    winTitle.textContent = `${winner} Wins!`;
    winTitle.className = winner === "X" ? "winner-X" : "winner-O";
    winScreen.classList.add("active");
  }
}

function checkGridLogic(accessorFn) {
  const lines = [
    [[0,0], [0,1], [0,2]], [[1,0], [1,1], [1,2]], [[2,0], [2,1], [2,2]], 
    [[0,0], [1,0], [2,0]], [[0,1], [1,1], [2,1]], [[0,2], [1,2], [2,2]], 
    [[0,0], [1,1], [2,2]], [[0,2], [1,1], [2,0]] 
  ];
  for (let line of lines) {
    const v0 = accessorFn(line[0][0], line[0][1]);
    const v1 = accessorFn(line[1][0], line[1][1]);
    const v2 = accessorFn(line[2][0], line[2][1]);
    if (v0 && v0 === v1 && v0 === v2) return v0;
  }
  return null;
}

function calculateNextConstraint(lastRow, lastCol) {
  const middleGridRowVal = Math.floor((lastRow % 9) / 3);
  const middleGridColVal = Math.floor((lastCol % 9) / 3);
  const cellRowVal = lastRow % 3;
  const cellColVal = lastCol % 3;
  const targetBigRow = middleGridRowVal;
  const targetBigCol = middleGridColVal;
  const targetMidRow = cellRowVal;
  const targetMidCol = cellColVal;
  const startRow = (targetBigRow * 9) + (targetMidRow * 3);
  const startCol = (targetBigCol * 9) + (targetMidCol * 3);
  const targetMgRow = (targetBigRow * 3) + targetMidRow;
  const targetMgCol = (targetBigCol * 3) + targetMidCol;
  const targetMgIndex = targetMgRow * 9 + targetMgCol;
  const targetBgIndex = targetBigRow * 3 + targetBigCol;

  nextMoveConstraint = { r: [startRow, startRow + 3], c: [startCol, startCol + 3] };
  if (middleGridState[targetMgIndex] !== null) { nextMoveConstraint = null; return; }
  if (bigGridState[targetBgIndex] !== null) { nextMoveConstraint = null; return; }
  if (isZoneFull(nextMoveConstraint)) { nextMoveConstraint = null; return; }
}

function isZoneFull(constraint) {
  for (let r = constraint.r[0]; r < constraint.r[1]; r++) {
    for (let c = constraint.c[0]; c < constraint.c[1]; c++) {
      if (cells[r * 27 + c].textContent === "") return false;
    }
  }
  return true;
}

function updateBoardVisuals() {
  cells.forEach(cell => {
    const r = parseInt(cell.dataset.row);
    const c = parseInt(cell.dataset.col);
    if (isGameOver || cell.textContent !== "") {
      cell.className = "cell"; 
      if(cell.textContent) applyMarkStyles(cell);
      restoreBorders(cell, r, c);
    } else if (isMoveLegal(r, c) && !isPaused) {
      cell.className = "cell legal-zone";
      restoreBorders(cell, r, c);
    } else {
      cell.className = "cell disabled-zone";
      restoreBorders(cell, r, c);
    }
  });
}

function restoreBorders(cell, r, c) {
  if ((c + 1) % 9 === 0) cell.classList.add("b-right-thick");
  else if ((c + 1) % 3 === 0) cell.classList.add("b-right-med");
  if ((r + 1) % 9 === 0) cell.classList.add("b-bottom-thick");
  else if ((r + 1) % 3 === 0) cell.classList.add("b-bottom-med");
}

function switchTurn() {
  turn = turn === "X" ? "O" : "X";
  bigMark.textContent = turn;
  turnContainer.className = turn === "X" ? "turn-x" : "turn-o";
}

function applyMarkStyles(cell) {
  cell.classList.remove("x-mark", "o-mark");
  if (cell.textContent === "X") cell.classList.add("x-mark");
  if (cell.textContent === "O") cell.classList.add("o-mark");
}

function createOverlay(row, col, winner, type) {
  const overlay = document.createElement("div");
  overlay.className = `won-overlay winner-${winner}`;
  overlay.textContent = winner;
  if (type === "middle") {
    overlay.classList.add("won-middle-grid");
    const sizePct = 100 / 9; 
    overlay.style.width = `${sizePct}%`; overlay.style.height = `${sizePct}%`;
    overlay.style.top = `${row * sizePct}%`; overlay.style.left = `${col * sizePct}%`;
  } else {
    overlay.classList.add("won-big-grid");
    const sizePct = 100 / 3; 
    overlay.style.width = `${sizePct}%`; overlay.style.height = `${sizePct}%`;
    overlay.style.top = `${row * sizePct}%`; overlay.style.left = `${col * sizePct}%`;
  }
  board.appendChild(overlay);
}

function saveGame() {
  const cellData = cells.map(c => c.textContent);
  const gameState = {
    turn,
    nextMoveConstraint,
    isGameOver,
    isVsComputer,
    playerSide,
    computerDifficulty,
    middleGridState,
    bigGridState,
    secondsElapsed,
    moveHistoryData,
    cellData,
    currentTheme,
    isMuted
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(gameState));
}

function loadGameState(state) {
  turn = state.turn;
  nextMoveConstraint = state.nextMoveConstraint;
  isGameOver = state.isGameOver;
  isVsComputer = state.isVsComputer;
  playerSide = state.playerSide || "X";
  computerDifficulty = state.computerDifficulty || "easy";
  middleGridState = state.middleGridState;
  bigGridState = state.bigGridState;
  secondsElapsed = state.secondsElapsed;
  moveHistoryData = state.moveHistoryData || [];
  isMuted = state.isMuted || false;
  if(isMuted) soundBtn.textContent = "ðŸ”‡";
  
  if (state.currentTheme) setTheme(state.currentTheme);

  const cellData = state.cellData;
  cells.forEach((cell, i) => {
    cell.textContent = cellData[i];
    applyMarkStyles(cell);
  });

  document.querySelectorAll(".won-overlay").forEach(o => o.remove()); 
  for(let i=0; i<81; i++) {
    if(middleGridState[i]) {
      const r = Math.floor(i / 9);
      const c = i % 9;
      createOverlay(r, c, middleGridState[i], "middle");
    }
  }
  for(let i=0; i<9; i++) {
    if(bigGridState[i]) {
      const r = Math.floor(i / 3);
      const c = i % 3;
      createOverlay(r, c, bigGridState[i], "big");
    }
  }

  activityLog.innerHTML = "";
  for(let i = moveHistoryData.length - 1; i >= 0; i--) {
    const move = moveHistoryData[i];
    renderLogEntry(move.player, move.r, move.c);
  }

  startScreen.classList.add("hidden");
  gameWrapper.classList.remove("hidden");
  gameWrapper.style.opacity = "1";
  bigMark.textContent = turn;
  turnContainer.className = turn === "X" ? "turn-x" : "turn-o";
  updateTimerDisplay();
  updateBoardVisuals();
  
  if(!isGameOver) startTimer(true);
}

function resetGame(returnToMenu = false, propagate = false) {
  stopTimer(); 
  localStorage.removeItem(SAVE_KEY); 
  
  turn = "X";
  nextMoveConstraint = null;
  isGameOver = false;
  isPaused = false;
  middleGridState.fill(null);
  bigGridState.fill(null);
  secondsElapsed = 0;
  moveHistoryData = [];
  
  cells.forEach(cell => {
    cell.textContent = "";
    cell.className = "cell legal-zone";
    const r = parseInt(cell.dataset.row);
    const c = parseInt(cell.dataset.col);
    restoreBorders(cell, r, c);
  });
  
  document.querySelectorAll(".won-overlay").forEach(o => o.remove());
  activityLog.innerHTML = "";
  winScreen.classList.remove("active");
  pauseScreen.classList.remove("active");
  ingameThemeModal.classList.remove("active");
  
  bigMark.textContent = "X";
  turnContainer.className = "turn-x";
  updateTimerDisplay();

  if (propagate && isOnline) {
    sendData({ type: 'reset' });
  }

  if (returnToMenu) {
    settingsScreen.classList.add("hidden"); 
    modeScreen.classList.add("hidden");
    friendSelectScreen.classList.add("hidden");
    onlineLobbyScreen.classList.add("hidden");
    sideSelectScreen.classList.add("hidden");
    
    // FIX: ensure game wrapper is fully hidden
    gameWrapper.style.opacity = "0";
    gameWrapper.classList.add("hidden"); 

    if (peer) { peer.destroy(); peer = null; isOnline = false; }
    setTimeout(() => {
      startScreen.classList.remove("hidden");
    }, 200);
  } else {
    updateBoardVisuals();
    startTimer();
  }
}
</script>
</body>
</html>
